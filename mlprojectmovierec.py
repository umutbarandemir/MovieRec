# -*- coding: utf-8 -*-
"""MLprojectMovieRec.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1oSQIjUcP6tsYkjpI5ZFacBmLh_3Z7xKF
"""

import numpy as np
from scipy.sparse import csr_matrix
import pandas as pd
import sklearn
from sklearn.neighbors import NearestNeighbors

movieRatings = pd.read_csv("https://s3-us-west-2.amazonaws.com/recommender-tutorial/ratings.csv")
movieRatings.head()

#Cutting out the unnecessary columns
movieRatings=movieRatings.drop('timestamp', axis=1)

#NEW DATA TABLE
movieRatings.head()

movieinfo = pd.read_csv("https://s3-us-west-2.amazonaws.com/recommender-tutorial/movies.csv")
movieinfo.head()

#Cutting out the unnecessary columns
movies=movieinfo.drop('genres', axis=1)

#NEW DATA TABLE
 movies.head()

moviesRatingCount = pd.DataFrame(movieRatings.groupby('movieId').size(), columns=['count'])
moviesRatingCount.head()

#to make more accurate recommendations, we need more than 2-3 common rated movies(eğer kullanıcı sadece 4-5 filmi puanlandırmışşsa, ona istabetli öneri yapmak mümkün olmaz. O yüzden aktif olmayan kullancıları ve filmleri kullanmamamız lazım)
#CLEANING MOVIES
Minnumofratings = 50 #threshhold number
suitablemovies = list(set(moviesRatingCount.query('count >= @Minnumofratings').index))
updatedmovieratings = movieRatings[movieRatings.movieId.isin(suitablemovies)]
print('Original ratings data : ', movieRatings.shape)
print('Ratings data after removing unpopular movies: ', updatedmovieratings.shape)

# number of ratings given by every user, we will need this value to eleminate inactive users
userActivity = pd.DataFrame(updatedmovieratings.groupby('userId').size(), columns=['count'])
userActivity.head()

#CLEANING USERS
userInteractions = 20 #threshhold number
suitableusers = list(set(userActivity.query('count >= @userInteractions').index))
updatedestuserratings = updatedmovieratings[updatedmovieratings.userId.isin(suitableusers)]
print('Original Ratings Data : ', movieRatings.shape)
print('Ratings data after dropping both unpopular movies and inactive users: ', updatedestuserratings.shape)

#with this function we will create the 'finalMatrix' which we will use to implement KNN on.
def user_ratingMatrix(moviedata):

    #number of uniqe movies and users
    uniqueUsers = len(moviedata['userId'].unique())
    uniqueMovies = len(moviedata['movieId'].unique())

    #these dictionaries map which row/column of the utility matrix responds to which user and movie ID'S.
    # user_mapper: maps user id to user index, movie_mapper: maps movie id to movie index
    user_mapper = dict(zip(np.unique(moviedata["userId"]), list(range(uniqueUsers))))
    movie_mapper = dict(zip(np.unique(moviedata["movieId"]), list(range(uniqueMovies))))

    # user_inv_mapper: maps user index to user id, movie_inv_mapper: maps movie index to movie id
    user_inv_mapper = dict(zip(list(range(uniqueUsers)), np.unique(moviedata["userId"])))
    movie_inv_mapper = dict(zip(list(range(uniqueMovies)), np.unique(moviedata["movieId"])))

    user_index = [user_mapper[i] for i in moviedata['userId']]
    movie_index = [movie_mapper[i] for i in moviedata['movieId']]

     #scipy sparse matrix
    finalMatrix =csr_matrix((moviedata["rating"], (movie_index, user_index)), shape=(uniqueMovies, uniqueUsers))
    return finalMatrix, user_mapper, movie_mapper, user_inv_mapper, movie_inv_mapper


finalMatrix, user_mapper, movie_mapper, user_inv_mapper, movie_inv_mapper = user_ratingMatrix(movieRatings)

print(finalMatrix)

def RecommendMovies(movie_id, finalMatrix, recNumber, metric='cosine', show_distance=False):

    neighborMovies = []

    movieINDEX = movie_mapper[movie_id]
    movie_vec = finalMatrix[movieINDEX]

    recNumber+=1 #this value is the amount of movies the model will recommend
    kNN = NearestNeighbors(n_neighbors=recNumber, algorithm="brute", metric=metric)
    kNN.fit(finalMatrix)
    movie_vec = movie_vec.reshape(1,-1)
    neighbour = kNN.kneighbors(movie_vec, return_distance=show_distance)

    for i in range(0,recNumber):
        n = neighbour.item(i)
        neighborMovies.append(movie_inv_mapper[n])
    neighborMovies.pop(0)
    return neighborMovies

#this is the variable that helps us get movie title with movie ID
movieTITLES = dict(zip(movies['movieId'], movies['title']))

likedMovie = 1

similarMOVIES = RecommendMovies(likedMovie, finalMatrix, recNumber=6)
MovieName = movieTITLES[likedMovie]

print(f"Because You Liked -> {MovieName}")
print(f'You Might Like These :')
for i in similarMOVIES:
    print(movieTITLES[i])